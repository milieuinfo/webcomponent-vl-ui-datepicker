import validate from 'validate.js';
import moment from 'moment';
import IBAN from 'iban';

// TODO: Revalidate on tab also, not only change (also on select)
const dataPrefix = `data-${vl.ns}`,
  fvErrorMsgAtt = `${dataPrefix}error-message`,
  fvValidationType = `${dataPrefix}validation-type`,
  fvFormValidationType = `${dataPrefix}validate-form-type`,
  fvErrorIDAtt = `${dataPrefix}error-id`,
  fvErrorClassAtt = `${dataPrefix}error-class`,
  fvErrorPlchAtt = `${dataPrefix}error-placeholder`,
  fvSuccessAttr = `${dataPrefix}validate-form-success`,
  fvSuccessClass = `${dataPrefix}success-class`,
  fvValidateAtt = `${dataPrefix}validate-form`,
  fvErrorParentAtt = `${dataPrefix}validate-error-parent`,
  fvDressedAtt = `${dataPrefix}formvalidation-dressed`,
  fvValidatorOptions = {fullMessages: false},
  fvAriaInvalidAtt = 'aria-invalid',
  fvAriaDescribedBy = 'aria-describedby',
  fvSelectClass = `js-${vl.ns}select`;

let fvFirstError = null;

/**
 * Validators
 * data, rrn, phone, iban, multiselect
 */
validate.extend(validate.validators.datetime, {
  parse: value => {
    return moment.utc(value, 'DD.MM.YYYY');
  },
  format: value => {
    return value;
  }
});

validate.validators.rrn = (value, options) => {
  let rrn, pattern;

  if (value) {
    rrn = value.toString();
    pattern = /^((([0-9]{2})\.){2})([0-9]{2})[-][0-9]{3}\.[0-9]{2}$/gi;

    if (!pattern.test(rrn)) {
      return options.message;
    }

    return;
  }

  return options.message;
};

validate.validators.phone = (value, options) => {
  let phone, pattern;

  if (value) {
    phone = value.toString();
    pattern = /^((\+|00)\s{0,1}32\s?|0)(\d\s?\d{3}|\d{2}\s?\d{2})(\s?\d{2}){2}$|^((\+|00)32\s?|0)4(60|[789]\d)(\s?\d{2}){3}$/gi;

    if (!pattern.test(phone)) {
      return options.message;
    }

    return;
  }

  return options.message;
};

validate.validators.iban = (value, options) => {
  let iban,
    pattern,
    replacement = '';

  if (value) {
    iban = value.toString();
    pattern = /\s/g;

    iban = iban.replace(pattern, replacement);

    if (!IBAN.isValid(iban)) {
      return options.message;
    }

    return;
  }

  return options.message;
};

validate.validators.multiSelect = (value, options) => {
  if (typeof value === 'undefined' || value.length === 0) {
    return options.message;
  }

  return;
};

/**
 * Builds the validation-constraints for our form
 * @method      _buildFormvalidationConfig
 * @param       {[object]}      obj [obj]
 * @return      {[object]}      [validationConstraints]
 */
const _buildFormvalidationConfig = obj => {
  let errorMessage = {message: obj.errorMessage};

  obj.validationConstraints.presence = errorMessage;

  switch (obj.validationType) {
    case 'email':
      obj.validationConstraints.email = {message: obj.errorMessage};
      break;
    case 'phone':
      obj.validationConstraints = {phone: errorMessage};
      break;
    case 'rrn':
      obj.validationConstraints = {rrn: errorMessage};
      break;
    case 'date':
      obj.validationConstraints.datetime = errorMessage;
      break;
    case 'multi-select':
      obj.validationConstraints.multiSelect = errorMessage;
      break;
    case 'iban':
      obj.validationConstraints.iban = errorMessage;
      break;
  }

  return obj.validationConstraints;
};

/**
 * Prepares form validation config
 * @method      _prepareFormvalidationConfig
 * @param       {[object]}   field  [element]
 * @param       {[object]}   config [description]
 */
const _prepareFormvalidationConfig = (field, config) => {
  let fieldObj = {},
    randomName,
    randomId;

  fieldObj.id = field.getAttribute('id');
  fieldObj.name = field.getAttribute('name');
  fieldObj.required = field.getAttribute('data-required');
  fieldObj.validationType = field.getAttribute(fvValidationType);
  fieldObj.errorMessage = field.getAttribute(fvErrorMsgAtt);
  fieldObj.validationConstraints = {};

  /**
   * if no name is set, set own name
   */
  if (!fieldObj.name) {
    randomName = 'field-' + vl.util.uniqueName();

    field.setAttribute('name', randomName);
    fieldObj.name = randomName;
  }

  /**
   * If no id is set, set own id
   */
  if (!fieldObj.id) {
    randomId = vl.util.uniqueId();

    field.setAttribute('id', randomId);
    fieldObj.id = randomId;
  }

  config.constraints[fieldObj.name] = _buildFormvalidationConfig(fieldObj);
};

/**
 * Submits form
 * @method      _formSubmit
 * @param       {[object]}    form
 */
const _formSubmit = form => {
  form.submit();
};

/**
 * Show an success-message for vl.util.each error (if needed)
 * @method      _showSuccessForInput
 * @param       {[type]}             input  [field]
 * @param       {[type]}             errors [errors]
 */
const _showSuccessForInput = (input, errors) => {
  if (!errors) {
    vl.util.removeClass(input, input.getAttribute(fvErrorClassAtt));

    if (input.form.getAttribute(fvSuccessAttr) === 'true') {
      vl.util.addClass(input, input.getAttribute(fvSuccessClass));
    }
    input.setAttribute(fvAriaInvalidAtt, false);

    if (
      input.getAttribute(fvValidationType) === 'multi-select' ||
      input.getAttribute(fvValidationType) === 'select'
    ) {
      if (vl.util.exists(input.closest(`[${fvSuccessClass}]`))) {
        vl.util.removeClass(
          input.closest(`[${fvErrorParentAtt}]`),
          input.getAttribute(fvErrorClassAtt)
        );
        vl.util.addClass(
          input.closest(`[${fvErrorParentAtt}]`),
          input.getAttribute(fvSuccessClass)
        );
      }
    }
  }
};

// Focus and scroll into view when form error on submit
const _focusOnFirstError = (input) => {
  // Only trigger on first error
  if (!vl.util.exists(fvFirstError)) {
    fvFirstError = input;

    if (vl.util.exists(fvFirstError)) {
      fvFirstError.focus();
      fvFirstError.scrollIntoView();
    }
  }
};

/**
 * Show an error-message for vl.util.each error (if needed)
 * @method      _showErrorsForInput
 * @param       {[object]}            input  [field]
 * @param       {[object]}            errors [errors]
 */
const _showErrorsForInput = (input, errors) => {
  let errorMessage = input.form.querySelector(
    `[${fvErrorIDAtt}="${input.getAttribute(fvErrorPlchAtt)}"]`
  );

  if (errors) {
    vl.util.each(errors, error => {
      vl.util.removeClass(input, input.getAttribute(fvSuccessClass));
      vl.util.addClass(input, input.getAttribute(fvErrorClassAtt));
      input.setAttribute(fvAriaInvalidAtt, true);
      errorMessage.innerHTML = error;
      errorMessage.setAttribute(fvAriaDescribedBy, input.getAttribute('id'));

      if (
        input.getAttribute(fvValidationType) === 'multi-select' ||
        input.getAttribute(fvValidationType) === 'select'
      ) {
        if (vl.util.exists(input.closest(`[${fvErrorParentAtt}]`))) {
          vl.util.removeClass(
            input.closest(`[${fvErrorParentAtt}]`),
            input.getAttribute(fvSuccessClass)
          );
          vl.util.addClass(
            input.closest(`[${fvErrorParentAtt}]`),
            input.getAttribute(fvErrorClassAtt)
          );
        }
      }
    });

    // Has errors - select correct input field and focus it
    _focusOnFirstError(input);
  }
};

/**
 * Controls the showing of errors over multiple elements
 * @method      _showErrors
 * @param       {[object]}    form   [form that gets validated]
 * @param       {[object]}    errors [errors]
 */
const _showErrors = (form, errors) => {
  vl.util.each(form.elements, input => {
    if (
      input.hasAttribute(fvErrorMsgAtt) &&
      input.hasAttribute(fvErrorPlchAtt) &&
      input.name.length &&
      form.querySelector(
        `[${fvErrorIDAtt}="${input.getAttribute(fvErrorPlchAtt)}"]`
      )
    ) {
      _showSuccessForInput(input, errors);
      _showErrorsForInput(input, errors && errors[input.name]);
    }
  });
};

/**
 * Controls the showing of success-states over multiple elements
 * @method      _showSuccess
 * @param       {[object]}    form   [form that gets validated]
 * @param       {[object]}    errors [errors]
 */
const _showSuccess = (form, errors) => {
  vl.util.each(form.elements, input => {
    if (input.name.length) {
      _showSuccessForInput(input, errors && errors[input.name]);
    }
  });
};

/**
 * Reset previous errors
 * @method      _resetErrorForInput
 * @param       {[object]}            input [description]
 * @constructor
 */
const _resetInput = input => {
  const errorPlaceholder = input.form.querySelector(
    `[${fvErrorIDAtt}="${input.getAttribute(fvErrorPlchAtt)}"]`
  );

  if (errorPlaceholder) {
    vl.util.removeClass(input, input.getAttribute(fvErrorClassAtt));

    if (input.form.getAttribute(fvSuccessAttr) === 'true') {
      vl.util.removeClass(input, input.getAttribute(fvSuccessClass));
    }

    errorPlaceholder.innerHTML = '';
    errorPlaceholder.removeAttribute('aria-describedBy');
  }
};

const _resetAllError = form => {
  vl.util.each(form.elements, input => {
    if (input.name) {
      _resetInput(input);
    }
  });
};

/**
 * Handle validation errors
 * @method      _handleErrors
 * @param       {[object]}    el           [element or form to validate]
 * @param       {[object]}    errors       [list of the errors]
 * @param       {Boolean}     isCollection [if true, an entire form gets validated]
 */
const _handleErrors = (el, errors, isCollection) => {
  if (isCollection) {
    _resetAllError(el);
    _showSuccess(el, errors);
    _showErrors(el, errors);
  } else {
    _resetInput(el);
    _showSuccessForInput(el, errors);
    _showErrorsForInput(el, errors);
  }
};

/**
 * Validates entire form
 * @method      _validateForm
 * @param       {[object]}      form   [the form to validate]
 * @param       {[object]}      config [the config file to validate against]
 */
const _validateForm = (form, config) => {
  let errors,
    constraints = config.constraints;

  errors = validate(form, constraints, fvValidatorOptions);

  _handleErrors(form, errors || {}, true);

  if (!errors) {
    _formSubmit(form);
  }
};

/**
 * Validates single field
 * @method      _validateField
 * @param       {[object]}       el     [field to validate]
 * @param       {[object]}       config [the config file to validate against]
 */
const _validateField = (el, config) => {
  let errors,
    constraints = config.constraints,
    fieldConstraints;

  fieldConstraints = {};
  fieldConstraints[el.name] = constraints[el.name];

  errors = validate(el.form, fieldConstraints, fvValidatorOptions) || {};
  _handleErrors(el, errors[el.name], false);
};

class FormValidation {
  dress(form) {
    let fields,
      validationConfig = {},
      validationFormType = form.getAttribute(fvFormValidationType),
      eventTargetSelect;

    validationConfig.constraints = {};

    form.setAttribute(fvDressedAtt, true);

    // if the form does not have an ID, create one in JS
    if (!form.id) {
      form.setAttribute('id', vl.util.uniqueId());
    }

    fields = form.querySelectorAll(
      `input, textarea, select, .${fvSelectClass}`
    );
    vl.util.each(fields, field => {
      _prepareFormvalidationConfig(field, validationConfig);

      if (validationFormType !== 'submit') {
        // When tabbing through fields, validate fields
        field.addEventListener('keydown', event => {
          if (event.keyCode === 9) {
            if (event.target) {
              eventTargetSelect = event.target.closest(`.${fvSelectClass}`);

              if (vl.util.exists(eventTargetSelect)) {
                _validateField(
                  eventTargetSelect.querySelector('select'),
                  validationConfig,
                  form
                );
              } else {
                _validateField(event.target, validationConfig, form);
              }
            }
          }
        });

        field.addEventListener(
          'change',
          vl.util.debounce(event => {
            _validateField(event.target, validationConfig, form);
          }, 100)
        );
      }
    });

    form.addEventListener('submit', event => {
      fvFirstError = null;
      event.preventDefault();

      _validateForm(event.target, validationConfig);
    });
  }

  dressAll() {
    const forms = document.querySelectorAll(
      `[${fvValidateAtt}]:not([${fvDressedAtt}]):not([data-${vl.ns}js-dress="false"])`
    );

    vl.util.each(forms, form => {
      this.dress(form);
    });
  }
}

if(!('formValidation' in vl)) {
  vl.formValidation = new FormValidation();
  vl.formValidation.dressAll();
}

export default FormValidation;
