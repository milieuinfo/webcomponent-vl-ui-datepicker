// Select.js
// Using choices.js
import Choices from 'choices.js';

// Private vars
const sClass = `${vl.ns}select`,
  sClassJs = `js-${sClass}`,
  sSelectorAtt = `data-${vl.ns}select`,
  sMultiSelectorAtt = `data-${vl.ns}multiselect`,
  sInnerClass = `${sClass}__inner`,
  sInputClass = `${vl.ns}input-field`,
  sInputClonedClass = `${sInputClass}-cloned`,
  sListClass = `${sClass}__list`,
  sListItemsClass = `${sListClass}--multiple`,
  sListSingleClass = `${sListClass}--single`,
  sListDropdownClass = `${sListClass}--dropdown`,
  sItemClass = `${sClass}__item`,
  sItemSelectableClass = `${sItemClass}--selectable`,
  sItemDisabledClass = `${sItemClass}--disabled`,
  sItemChoiceClass = `${sItemClass}--choice`,
  sPlaceholderClass = `${sClass}__placeholder`,
  sGroupClass = `${sClass}__group`,
  sHeadingClass = `${sClass}__heading`,
  sButtonClass = `${sClass}__button`,
  pillClass = `${vl.ns}pill`,
  pillCloseClass = `${pillClass}__close`,
  sDressedAtt = `${sSelectorAtt}-dressed`,
  sMultiDressedAtt = `${sMultiSelectorAtt}-dressed`,
  sSearchAtt = `${sSelectorAtt}-search`,
  sdeletableAtt = `${sSelectorAtt}-deletable`,
  sSearchEmptyAtt = `${sSelectorAtt}-search-empty-text`;

const _prepareChoisesConfig = element => {
  let obj = {},
    searchEnabled = true,
    removeItemButton = false,
    searchPlaceholderValue = vl.i18n.t('select.search_placeholder_value'),
    placeholderValue = vl.i18n.t('select.placeholder_value'),
    disabled = false;

  // Select has search - default behavior
  if (element.hasAttribute(sSearchAtt)) {
    searchEnabled = element.getAttribute(sSearchAtt) === 'true';
  }

  // Select is disabled
  disabled = element.disabled;

  // Select has empty-search-text attribute
  if (element.hasAttribute(sSearchEmptyAtt)) {
    obj.noResultsText = element.getAttribute(sSearchEmptyAtt);
  }

  if (element.hasAttribute(sMultiSelectorAtt) || element.hasAttribute(sdeletableAtt)) {
    removeItemButton = true;
  }

  obj.searchEnabled = searchEnabled;
  obj.removeItemButton = removeItemButton;
  obj.searchPlaceholderValue = searchPlaceholderValue;
  obj.placeholderValue = placeholderValue;
  obj.disabled = disabled;

  return obj;
};

class Select {
  constructor() {
    this.selectInstances = [];
    this.globalConfig = {
      removeItemButton: false,
      searchEnabled: true,
      addItems: true,
      classNames: {
        containerOuter: sClassJs,
        containerInner: sInnerClass,
        input: sInputClass,
        inputCloned: sInputClonedClass,
        list: sListClass,
        listItems: sListItemsClass,
        listSingle: sListSingleClass,
        listDropdown: sListDropdownClass,
        item: sItemClass,
        itemSelectable: sItemSelectableClass,
        itemDisabled: sItemDisabledClass,
        itemChoice: sItemChoiceClass,
        placeholder: sPlaceholderClass,
        group: sGroupClass,
        groupHeading: sHeadingClass,
        button: sButtonClass
      },
      noResultsText: vl.i18n.t('select.no_results'),
      noChoicesText: vl.i18n.t('select.no_more_options'),
      callbackOnCreateTemplates: this._createTemplates
    };
  }

  _createTemplates(template) {
    const classNames = this.config.classNames;

    return {
      itemList: () => {
        if (this.passedElement.type === 'select-one') {
          return template(`
            <div class="${classNames.input}"></div>
          `);
        }

        return template(`
          <div class="${classNames.input} ${classNames.listItems}"></div>`);
      },
      item: data => {
        // Still issue with placeholder on select with optGroups
        // https://github.com/jshjohnson/Choices/issues/224
        if (this.config.removeItemButton) {
          return template(`
              <div class="${classNames.item}
                ${data.highlighted ? classNames.highlightedState : ''}
                ${data.disabled ? '' : classNames.itemSelectable}
                ${this.passedElement.type === 'select-one' ? '' : pillClass}
                ${data.placeholder ? classNames.placeholder : ''}"
                data-item data-id="${data.id}"
                data-value="${data.value}"
                ${data.active ? 'aria-selected="true"' : ''}
                ${data.disabled ? 'aria-disabled="true"' : 'data-deletable'}>
                <span>${data.label}</span>
                <button class="${pillCloseClass}" data-button>
                  <span class="vl-u-visually-hidden">Remove item</span>
                </button>
              </div>
            `);
        }

        return template(`
          <div class="${classNames.item}
            ${data.highlighted ?
    classNames.highlightedState :
    classNames.itemSelectable}
            ${data.placeholder ? classNames.placeholder : ''}"
            data-item data-id="${data.id}"
            data-value="${data.value}"
            ${data.active ? 'aria-selected="true"' : ''}
            ${data.disabled ? 'aria-disabled="true"' : ''}>
            ${data.label}
          </div>
          `);
      },
      input: () => {
        return template(`
          <input type="text" class="${classNames.input}
            ${classNames.inputCloned}"
            autocomplete="off"
            autocapitalize="off"
            spellcheck="false"
            role="textbox"
            aria-autocomplete="list">
          `);
      }
    };
  }

  _buildSelect(select, config, params, originalOptions) {
    let choice = new Choices(select, config),
      items = [];

    if (vl.util.exists(params.callbackFn)) {
      items = params.callbackFn(select);

      this._callback(choice, items);
    }

    if (config.disabled) {
      choice.disable();
    }

    choice.originalOptions = originalOptions;

    this.selectInstances.push(choice);
  }

  _callback(choice, items) {
    choice.setChoices(items, 'value', 'label', false);
  }

  removeActive(select) {
    vl.util.each(this.selectInstances, instance => {
      if (instance.element === select) {
        // Again here is an issue with the placeholder
        // The entire select would be cleared and no placeholder would be set,

        // Should be:
        // instance.removeActiveItems();

        // Dirty-ish fix, trigger click on working button
        const closeButton = instance.containerOuter.querySelector(`.${pillCloseClass}`);

        if (vl.util.exists(closeButton)) {
          vl.util.triggerEvent(closeButton, 'click');
        } else {
          instance.removeActiveItems();
        }
      }
    });
  }

  disable(select) {
    vl.util.each(this.selectInstances, instance => {
      if (instance.element === select) {
        instance.disable();
      }
    });
  }

  enable(select) {
    vl.util.each(this.selectInstances, instance => {
      if (instance.element === select) {
        instance.enable();
      }
    });
  }

  setValueByChoice(select, value) {
    vl.util.each(this.selectInstances, instance => {
      if (instance.element === select) {
        instance.setValueByChoice(value);
      }
    });
  }

  dress(select, params = {}) {
    let config = {},
      originalOptions = select.querySelectorAll('option');

    select.setAttribute(sDressedAtt, true);

    // Build select config
    config = _prepareChoisesConfig(select);
    config = Object.assign(this.globalConfig, config);

    this._buildSelect(select, config, params, originalOptions);
  }

  undress(selectInstance) {
    let selectId = selectInstance.element.id,
      selectEl;

    selectInstance.element.removeAttribute(sDressedAtt);
    selectInstance.element.removeAttribute(sMultiDressedAtt);

    // Destroy is not working correctly, initial state will not be correctly reset
    // https://github.com/jshjohnson/Choices/issues/298
    selectInstance.destroy();

    selectEl = document.getElementById(selectId);

    vl.util.each(selectInstance.originalOptions, option => {
      selectEl.appendChild(option);
    });

    // Reset select to first value
    selectEl.selectedIndex = 0;
  }

  dressAll() {
    const selectFields = document.querySelectorAll(
        `[${sSelectorAtt}]:not([${sDressedAtt}]):not([data-${vl.ns}js-dress="false"])`
      ),
      multiSelectFields = document.querySelectorAll(
        `[${sMultiSelectorAtt}]:not([${sMultiDressedAtt}]):not([data-${vl.ns}js-dress="false"])`
      );

    vl.util.each(selectFields, select => {
      this.dress(select);
    });

    vl.util.each(multiSelectFields, multiSelect => {
      this.dress(multiSelect);
    });
  }

  undressAll() {
    if (vl.util.exists(this.selectInstances)) {
      vl.util.each(this.selectInstances, selectInstance => {
        this.undress(selectInstance);
      });
    }

    this.selectInstances = [];
  }
}

if(!('select' in vl)) {
  vl.select = new Select();
  vl.select.dressAll();
}

export default Select;
