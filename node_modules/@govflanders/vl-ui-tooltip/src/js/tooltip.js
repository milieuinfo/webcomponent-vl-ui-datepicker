/**
 * Tooltip
 **/
import TooltipJS from 'tooltip.js';

/**
 * Private Variables
 */

const ttClass = `js-${vl.ns}tooltip`,
  dataPrefix = `data-${vl.ns}`,
  ttAtt = `${dataPrefix}tooltip`,
  ttPlacementAtt = `${ttAtt}-placement`,
  ttContentAtt = `${ttAtt}-content`;

const ttTemplate =
  '<div class="vl-tooltip vl-typography" role="tooltip" aria-hidden="true">' +
  '<div class="vl-tooltip__arrow"></div>' +
  '<div class="tooltip__inner">' +
  '</div></div>';

const ttTemplateLarge =
  '<div class="vl-tooltip vl-tooltip--large vl-typography" role="tooltip" aria-hidden="true">' +
  '<div class="vl-tooltip__arrow"></div>' +
  '<div class="tooltip__inner">' +
  '</div></div>';

/**
 * Private Functions
 */

/**
 * add close by escape support
 * @param tooltip
 * @private
 */
const _addEscapeSupport = tooltip => {
  document.addEventListener('keyup', evt => {
    evt = evt || window.event;
    let isEscape = false;

    if ('key' in evt) {
      isEscape = evt.key === 'Escape' || evt.key === 'Esc';
    } else {
      isEscape = evt.keyCode === 27;
    }

    if (isEscape) {
      tooltip.hide();
    }
  });
};

class Tooltip {
  constructor() {
    this.tooltips = [];
  }
  /**
   * dress one element
   * @param element
   */
  dress(element) {
    this.createTooltip(element);
  }

  /**
   * dressAll function for the accordion functionality
   * @return {false}
   */
  dressAll() {
    // get all elements
    const elements = document.querySelectorAll(
      `.${ttClass}:not([data-${vl.ns}js-dress="false"]),
      [${ttAtt}]:not([data-${vl.ns}js-dress="false"])`
    );

    // add functionality to the map
    vl.util.each(elements, element => {
      this.dress(element);
    });
  }

  /**
   * undress function removes tooltip instance
   * @return {false}
   */
  undress(instance) {
    if (instance && typeof instance.dispose === 'function') {
      instance.dispose();
      
      this.tooltips = this.tooltips.filter(tooltip => tooltip.tooltipRef !== instance);
    }
  }

  /**
   * undressAll function for the accordion functionality
   * @return {false}
   */
  undressAll() {
    vl.util.each(this.tooltips, (tooltip) => {
      this.undress(tooltip.tooltipRef);
    });
  }

  /**
   * updates the content of the tooltip
   * @param target
   * @param content
   */
  updateTitleContent(target, content) {
    vl.util.each(this.tooltips, tooltip => {
      if (target === tooltip.element) {
        tooltip.tooltipRef.updateTitleContent(content);
      }
    });
  }

  /**
   * create a tooltip instance
   * @param element
   * @private
   */
  createTooltip(element) {
    let placement = element.getAttribute(ttPlacementAtt),
      title = element.getAttribute(ttContentAtt),
      template = title.length > 80 ? ttTemplateLarge : ttTemplate,
      offset = '0,10';

    placement = placement === null ? 'top' : placement;

    const options = {
      placement: placement,
      template: template,
      offset: offset,
      html: true,
      title: title
    };

    const tooltip = new TooltipJS(element, options);

    this.tooltips.push({element: element, tooltipRef: tooltip});

    _addEscapeSupport(tooltip);
  };
}

if(!('tooltip' in vl)) {
  vl.tooltip = new Tooltip();
  vl.tooltip.dressAll();
}

export default Tooltip;
